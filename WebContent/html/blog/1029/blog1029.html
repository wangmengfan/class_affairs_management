<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="/img/favicon.ico" type="image/x-icon" rel="shortcut icon" /> 
<title></title>
<style type="text/css">
#static_introduce table{width:520px !important;}
#static_introduce{word-wrap:break-word;word-break:break-all;}
</style>
</head>
<body>
<div id="static_introduce">Spring：　　Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由 Rod Johnson在其著作
Expert One-On-One J2EE Development and Design
中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为
 J2EE 应用程序开发提供集成的框架。Spring 使用基本的 JavaBean来完成以前只可能由 EJB 完成的事情。然而，Spring
的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益。Spring
的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring 是一个分层的 JavaSE/EEfull-stack( 一站式)
轻量级开源框架。JavaEE 开发分成三层结构:* WEB 层:Spring MVC.* 业务层:Bean 管理:(IOC)* 持久层:Spring 的 JDBC 模板.ORM 模板用于整合其他的持久层框架.Spring的优势：方便解耦，简化开发　　Spring 就是一个大工厂，可以将所有对象创建和依赖关系维护，交给 Spring 管理AOP 编程的支持　　Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能声明式事务的支持　　只需要通过配置就可以完成对事务的管理，而无需手动编程方便程序的测试　　Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序方便集成各种优秀框架　　Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持降低 JavaEE API 的使用难度　　Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低SpringIOC底层实现原理：相关概念：依赖注入和 控制反转IOC  inversion of control 控制反转DI  Dependency Injection 依赖注入IoC是什么Ioc—Inversion of
Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：●谁控制谁，控制什么：传统Java
SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC
 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。用图例说明一下，传统程序设计如图，都是主动去创建相关对象然后再组合起来：传统应用程序示意图当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了IoC能做什么IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。IoC和DIDI—Dependency
Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</div>

</body>

</html>